// Code generated by goa v3.14.1, DO NOT EDIT.
//
// moltservice HTTP client types
//
// Command:
// $ goa gen github.com/cockroachdb/molt/moltservice/design -o ./moltservice

package client

import (
	moltservice "github.com/cockroachdb/molt/moltservice/gen/moltservice"
	goa "goa.design/goa/v3/pkg"
)

// CreateFetchTaskRequestBody is the type of the "moltservice" service
// "create_fetch_task" endpoint HTTP request body.
type CreateFetchTaskRequestBody struct {
	// source database connection string
	SourceConn string `form:"source_conn" json:"source_conn" xml:"source_conn"`
	// target database connection string
	TargetConn string `form:"target_conn" json:"target_conn" xml:"target_conn"`
	// Mode of operation for fetch
	Mode string `form:"mode" json:"mode" xml:"mode"`
	// Type of intermediary store
	Store string `form:"store" json:"store" xml:"store"`
	// whether the intermediate store should be cleaned up after the fetch task
	CleanupIntermediaryStore bool `form:"cleanup_intermediary_store" json:"cleanup_intermediary_store" xml:"cleanup_intermediary_store"`
	// the absolute or relative path to write export files
	LocalPath string `form:"local_path" json:"local_path" xml:"local_path"`
	// the local address where the file server will be spun up
	LocalPathListenAddress string `form:"local_path_listen_address" json:"local_path_listen_address" xml:"local_path_listen_address"`
	// the local address CRDB will use to access the import files
	LocalPathCrdbAddress string `form:"local_path_crdb_address" json:"local_path_crdb_address" xml:"local_path_crdb_address"`
	// the local address CRDB will use to access the import files
	BucketName string `form:"bucket_name" json:"bucket_name" xml:"bucket_name"`
	// the sub-path within the bucket to write the export files
	BucketPath string `form:"bucket_path" json:"bucket_path" xml:"bucket_path"`
	// if specified, writes task execution logs to a file and stdout; otherwise,
	// just writes to stdout
	LogFile string `form:"log_file" json:"log_file" xml:"log_file"`
	// if specified, truncates the target tables before running the data load
	Truncate bool `form:"truncate" json:"truncate" xml:"truncate"`
	// compression type
	Compression string `form:"compression" json:"compression" xml:"compression"`
	// number of rows for the export before data is flushed to the disk (persisted)
	NumFlushRows int `form:"num_flush_rows" json:"num_flush_rows" xml:"num_flush_rows"`
	// number of bytes for the export before data is flushed to the disk
	NumFlushBytes int `form:"num_flush_bytes" json:"num_flush_bytes" xml:"num_flush_bytes"`
	// number of tables to process at the same time; this is usually sized based on
	// number of CPUs
	NumConcurrentTables int `form:"num_concurrent_tables" json:"num_concurrent_tables" xml:"num_concurrent_tables"`
	// number of rows to export at a given time for each iteration; tune this so
	// that you get most out of CPU and can batch the most data together
	NumBatchRowsExport int `form:"num_batch_rows_export" json:"num_batch_rows_export" xml:"num_batch_rows_export"`
	// name for pg replication slot
	PgLogicalSlotName string `form:"pg_logical_slot_name" json:"pg_logical_slot_name" xml:"pg_logical_slot_name"`
	// name for pg replication plugin
	PgLogicalPlugin string `form:"pg_logical_plugin" json:"pg_logical_plugin" xml:"pg_logical_plugin"`
	// if set and exists, drops the existing replication slot
	PgDropSlot bool `form:"pg_drop_slot" json:"pg_drop_slot" xml:"pg_drop_slot"`
	// the name of the fetch run
	Name string `form:"name" json:"name" xml:"name"`
}

// GetFetchTasksResponseBody is the type of the "moltservice" service
// "get_fetch_tasks" endpoint HTTP response body.
type GetFetchTasksResponseBody []*FetchRunResponse

// GetSpecificFetchTaskResponseBody is the type of the "moltservice" service
// "get_specific_fetch_task" endpoint HTTP response body.
type GetSpecificFetchTaskResponseBody struct {
	// ID of the run
	ID *int `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// name of the fetch run
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// status of the fetch run
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// started at time
	StartedAt *int `form:"started_at,omitempty" json:"started_at,omitempty" xml:"started_at,omitempty"`
	// finished at time
	FinishedAt *int `form:"finished_at,omitempty" json:"finished_at,omitempty" xml:"finished_at,omitempty"`
	// fetch statistics
	Stats *FetchStatsDetailedResponseBody `form:"stats,omitempty" json:"stats,omitempty" xml:"stats,omitempty"`
	// logs for fetch run
	Logs []*LogResponseBody `form:"logs,omitempty" json:"logs,omitempty" xml:"logs,omitempty"`
	// verify runs linked to fetch runs
	VerifyRuns []*VerifyRunResponseBody `form:"verify_runs,omitempty" json:"verify_runs,omitempty" xml:"verify_runs,omitempty"`
}

// GetVerifyTasksResponseBody is the type of the "moltservice" service
// "get_verify_tasks" endpoint HTTP response body.
type GetVerifyTasksResponseBody []*VerifyRunResponse

// FetchRunResponse is used to define fields on response body types.
type FetchRunResponse struct {
	// ID of the run
	ID *int `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// name of the fetch run
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// status of the fetch run
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// started at time
	StartedAt *int `form:"started_at,omitempty" json:"started_at,omitempty" xml:"started_at,omitempty"`
	// finished at time
	FinishedAt *int `form:"finished_at,omitempty" json:"finished_at,omitempty" xml:"finished_at,omitempty"`
}

// FetchStatsDetailedResponseBody is used to define fields on response body
// types.
type FetchStatsDetailedResponseBody struct {
	// percentage complete of fetch run
	PercentComplete *string `form:"percent_complete,omitempty" json:"percent_complete,omitempty" xml:"percent_complete,omitempty"`
	// number of errors processed
	NumErrors *int `form:"num_errors,omitempty" json:"num_errors,omitempty" xml:"num_errors,omitempty"`
	// number of tables processed
	NumTables *int `form:"num_tables,omitempty" json:"num_tables,omitempty" xml:"num_tables,omitempty"`
	// number of rows
	NumRows *int `form:"num_rows,omitempty" json:"num_rows,omitempty" xml:"num_rows,omitempty"`
	// net duration in milliseconds
	NetDurationMs *float64 `form:"net_duration_ms,omitempty" json:"net_duration_ms,omitempty" xml:"net_duration_ms,omitempty"`
	// import duration in milliseconds
	ImportDurationMs *float64 `form:"import_duration_ms,omitempty" json:"import_duration_ms,omitempty" xml:"import_duration_ms,omitempty"`
	// export duration in milliseconds
	ExportDurationMs *float64 `form:"export_duration_ms,omitempty" json:"export_duration_ms,omitempty" xml:"export_duration_ms,omitempty"`
	// CDC cursor
	CdcCursor *string `form:"cdc_cursor,omitempty" json:"cdc_cursor,omitempty" xml:"cdc_cursor,omitempty"`
}

// LogResponseBody is used to define fields on response body types.
type LogResponseBody struct {
	// timestamp of log
	Timestamp *int `form:"timestamp,omitempty" json:"timestamp,omitempty" xml:"timestamp,omitempty"`
	// level for logging
	Level *string `form:"level,omitempty" json:"level,omitempty" xml:"level,omitempty"`
	// message for the logging
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
}

// VerifyRunResponseBody is used to define fields on response body types.
type VerifyRunResponseBody struct {
	// ID of the run
	ID *int `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// name of the run
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// status of the run
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// started at time
	StartedAt *int `form:"started_at,omitempty" json:"started_at,omitempty" xml:"started_at,omitempty"`
	// finished at time
	FinishedAt *int `form:"finished_at,omitempty" json:"finished_at,omitempty" xml:"finished_at,omitempty"`
	// ID of the associated fetch run
	FetchID *int `form:"fetch_id,omitempty" json:"fetch_id,omitempty" xml:"fetch_id,omitempty"`
}

// VerifyRunResponse is used to define fields on response body types.
type VerifyRunResponse struct {
	// ID of the run
	ID *int `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// name of the run
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// status of the run
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// started at time
	StartedAt *int `form:"started_at,omitempty" json:"started_at,omitempty" xml:"started_at,omitempty"`
	// finished at time
	FinishedAt *int `form:"finished_at,omitempty" json:"finished_at,omitempty" xml:"finished_at,omitempty"`
	// ID of the associated fetch run
	FetchID *int `form:"fetch_id,omitempty" json:"fetch_id,omitempty" xml:"fetch_id,omitempty"`
}

// NewCreateFetchTaskRequestBody builds the HTTP request body from the payload
// of the "create_fetch_task" endpoint of the "moltservice" service.
func NewCreateFetchTaskRequestBody(p *moltservice.CreateFetchPayload) *CreateFetchTaskRequestBody {
	body := &CreateFetchTaskRequestBody{
		SourceConn:               p.SourceConn,
		TargetConn:               p.TargetConn,
		Mode:                     p.Mode,
		Store:                    p.Store,
		CleanupIntermediaryStore: p.CleanupIntermediaryStore,
		LocalPath:                p.LocalPath,
		LocalPathListenAddress:   p.LocalPathListenAddress,
		LocalPathCrdbAddress:     p.LocalPathCrdbAddress,
		BucketName:               p.BucketName,
		BucketPath:               p.BucketPath,
		LogFile:                  p.LogFile,
		Truncate:                 p.Truncate,
		Compression:              p.Compression,
		NumFlushRows:             p.NumFlushRows,
		NumFlushBytes:            p.NumFlushBytes,
		NumConcurrentTables:      p.NumConcurrentTables,
		NumBatchRowsExport:       p.NumBatchRowsExport,
		PgLogicalSlotName:        p.PgLogicalSlotName,
		PgLogicalPlugin:          p.PgLogicalPlugin,
		PgDropSlot:               p.PgDropSlot,
		Name:                     p.Name,
	}
	return body
}

// NewCreateFetchTaskFetchAttemptIDOK builds a "moltservice" service
// "create_fetch_task" endpoint result from a HTTP "OK" response.
func NewCreateFetchTaskFetchAttemptIDOK(body int) moltservice.FetchAttemptID {
	v := moltservice.FetchAttemptID(body)

	return v
}

// NewGetFetchTasksFetchRunOK builds a "moltservice" service "get_fetch_tasks"
// endpoint result from a HTTP "OK" response.
func NewGetFetchTasksFetchRunOK(body []*FetchRunResponse) []*moltservice.FetchRun {
	v := make([]*moltservice.FetchRun, len(body))
	for i, val := range body {
		v[i] = unmarshalFetchRunResponseToMoltserviceFetchRun(val)
	}

	return v
}

// NewGetSpecificFetchTaskFetchRunDetailedOK builds a "moltservice" service
// "get_specific_fetch_task" endpoint result from a HTTP "OK" response.
func NewGetSpecificFetchTaskFetchRunDetailedOK(body *GetSpecificFetchTaskResponseBody) *moltservice.FetchRunDetailed {
	v := &moltservice.FetchRunDetailed{
		ID:         *body.ID,
		Name:       *body.Name,
		Status:     *body.Status,
		StartedAt:  *body.StartedAt,
		FinishedAt: *body.FinishedAt,
	}
	if body.Stats != nil {
		v.Stats = unmarshalFetchStatsDetailedResponseBodyToMoltserviceFetchStatsDetailed(body.Stats)
	}
	v.Logs = make([]*moltservice.Log, len(body.Logs))
	for i, val := range body.Logs {
		v.Logs[i] = unmarshalLogResponseBodyToMoltserviceLog(val)
	}
	v.VerifyRuns = make([]*moltservice.VerifyRun, len(body.VerifyRuns))
	for i, val := range body.VerifyRuns {
		v.VerifyRuns[i] = unmarshalVerifyRunResponseBodyToMoltserviceVerifyRun(val)
	}

	return v
}

// NewCreateVerifyTaskFromFetchVerifyAttemptIDOK builds a "moltservice" service
// "create_verify_task_from_fetch" endpoint result from a HTTP "OK" response.
func NewCreateVerifyTaskFromFetchVerifyAttemptIDOK(body int) moltservice.VerifyAttemptID {
	v := moltservice.VerifyAttemptID(body)

	return v
}

// NewGetVerifyTasksVerifyRunOK builds a "moltservice" service
// "get_verify_tasks" endpoint result from a HTTP "OK" response.
func NewGetVerifyTasksVerifyRunOK(body []*VerifyRunResponse) []*moltservice.VerifyRun {
	v := make([]*moltservice.VerifyRun, len(body))
	for i, val := range body {
		v[i] = unmarshalVerifyRunResponseToMoltserviceVerifyRun(val)
	}

	return v
}

// ValidateGetSpecificFetchTaskResponseBody runs the validations defined on
// get_specific_fetch_task_response_body
func ValidateGetSpecificFetchTaskResponseBody(body *GetSpecificFetchTaskResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.StartedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("started_at", "body"))
	}
	if body.FinishedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("finished_at", "body"))
	}
	if body.Logs == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("logs", "body"))
	}
	if body.VerifyRuns == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("verify_runs", "body"))
	}
	if body.Status != nil {
		if !(*body.Status == "IN_PROGRESS" || *body.Status == "SUCCESS" || *body.Status == "FAILURE") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []any{"IN_PROGRESS", "SUCCESS", "FAILURE"}))
		}
	}
	if body.Stats != nil {
		if err2 := ValidateFetchStatsDetailedResponseBody(body.Stats); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range body.Logs {
		if e != nil {
			if err2 := ValidateLogResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.VerifyRuns {
		if e != nil {
			if err2 := ValidateVerifyRunResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateFetchRunResponse runs the validations defined on fetch_runResponse
func ValidateFetchRunResponse(body *FetchRunResponse) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.StartedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("started_at", "body"))
	}
	if body.FinishedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("finished_at", "body"))
	}
	if body.Status != nil {
		if !(*body.Status == "IN_PROGRESS" || *body.Status == "SUCCESS" || *body.Status == "FAILURE") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []any{"IN_PROGRESS", "SUCCESS", "FAILURE"}))
		}
	}
	return
}

// ValidateFetchStatsDetailedResponseBody runs the validations defined on
// fetch_stats_detailedResponseBody
func ValidateFetchStatsDetailedResponseBody(body *FetchStatsDetailedResponseBody) (err error) {
	if body.PercentComplete == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("percent_complete", "body"))
	}
	if body.NumErrors == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("num_errors", "body"))
	}
	if body.NumTables == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("num_tables", "body"))
	}
	if body.NumRows == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("num_rows", "body"))
	}
	if body.NetDurationMs == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("net_duration_ms", "body"))
	}
	if body.ImportDurationMs == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("import_duration_ms", "body"))
	}
	if body.ExportDurationMs == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("export_duration_ms", "body"))
	}
	if body.CdcCursor == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("cdc_cursor", "body"))
	}
	return
}

// ValidateLogResponseBody runs the validations defined on logResponseBody
func ValidateLogResponseBody(body *LogResponseBody) (err error) {
	if body.Timestamp == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timestamp", "body"))
	}
	if body.Level == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("level", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	return
}

// ValidateVerifyRunResponseBody runs the validations defined on
// verify_runResponseBody
func ValidateVerifyRunResponseBody(body *VerifyRunResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.StartedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("started_at", "body"))
	}
	if body.FinishedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("finished_at", "body"))
	}
	if body.FetchID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fetch_id", "body"))
	}
	if body.Status != nil {
		if !(*body.Status == "IN_PROGRESS" || *body.Status == "SUCCESS" || *body.Status == "FAILURE") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []any{"IN_PROGRESS", "SUCCESS", "FAILURE"}))
		}
	}
	return
}

// ValidateVerifyRunResponse runs the validations defined on verify_runResponse
func ValidateVerifyRunResponse(body *VerifyRunResponse) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.StartedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("started_at", "body"))
	}
	if body.FinishedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("finished_at", "body"))
	}
	if body.FetchID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fetch_id", "body"))
	}
	if body.Status != nil {
		if !(*body.Status == "IN_PROGRESS" || *body.Status == "SUCCESS" || *body.Status == "FAILURE") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []any{"IN_PROGRESS", "SUCCESS", "FAILURE"}))
		}
	}
	return
}
